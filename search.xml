<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>🧔Mysql索引</title>
      <link href="/2020/09/04/MySql%20%E7%B4%A2%E5%BC%95%E6%A6%82%E8%A7%88/"/>
      <url>/2020/09/04/MySql%20%E7%B4%A2%E5%BC%95%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h3 id="索引是万能的吗？"><a href="#索引是万能的吗？" class="headerlink" title="索引是万能的吗？"></a>索引是万能的吗？</h3><p>首先要了解什么是索引(index)。数据库中的索引，就好比一本书的目录，它可以帮我们快速进行特定值的定位与查找，从而加快数据查询的效率。</p><p>索引就是帮助数据库管理系统搞笑获取数据的数据结构。</p><p>索引不是万能的，在有些情况下使用索引反而会让效率变低。</p><p>在数据表中的数据行数比较少的情况下，比如不到1000行，是不需要创建索引的。另外，当数据重复度大，比如高于10%的时候，也不需要对这个字段创建索引。</p><h3 id="索引的种类有哪些"><a href="#索引的种类有哪些" class="headerlink" title="索引的种类有哪些"></a>索引的种类有哪些</h3><p>从功能逻辑上说，索引主要有4种，分别是普通索引、唯一索引、主键索引和全文索引。</p><p>普通索引是基础的索引，没有任何约束，主要用于提高查询效率。唯一索引就是在普通索引的基础上增加了数据唯一性的约束，在一张数据表里可以有多个唯一索引。主键索引在唯一索引的基础上增加了不为空的约束，也就是NOT NULL + UNIQUE，一张表里最多只有一个主键索引。全文索引用的不多，MySQL自带的全文索引只支持英文。我们通常可以采用专门的全文搜索引擎，比如ES。</p><p>其实前三种索引（普通索引，唯一索引，主键索引）都是一类索引，只不过对数据的约束性逐渐提升。在一张数据表中只能有一个主键索引，这是由主键索引的物理方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。但可以有多个普通索引或多个唯一索引。</p><p>按照物理实现方式，索引可以分为2种：聚集索引和非聚集索引。我们也可以把非聚集索引称为二级索引或者辅助索引。</p><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>聚集索引可以按照主键来排序存储数据，这样在查找行的时候非常有效。举个例子，如果是一本汉语字典，我们想要查找“数”这个字，直接在书中找汉语拼音的位置即可，也就是拼音shu。这样找到了索引的位置，在他后面就是我们想要找的数据行。</p><h4 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h4><p>在数据库系统会有单独的存储空间存放非聚集索引，这些索引项是按照顺序存储的，但索引项指向的内容是随机存储的。也就是说系统会进行两次查找，第一次先找到索引，第二次找到索引对应的位置取出数据行。非聚集索引不会把索引指向的内容像聚集索引一样直接放到索引的后面，而是维护单独的索引表（只维护索引，不维护索引指向的数据），为数据的检索提供方便。还以汉语字典为例，如果想要查找“数”字，那么按照部首查找的方式，先找到“数”字的偏旁部首，然后这个目录会告诉我们“数字”存放在低多少页，我们再去指定的页码找到这个字。</p><p>聚集索引与非聚集索引的原理不同，在使用上也有一些区别：</p><ol><li>聚集索引的叶子节点存储的就是我们的数据记录，非聚集索引的叶子节点存储的是数据位置。非聚集索引不会影响数据表的物理存储结构。</li><li>一个表只能有一个聚集索引，因为只能有一种排序存储的方式，但可以有多个非聚集索引，也就是多个索引目录提供数据检索，</li><li>使用聚集索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚集索引低。</li></ol><p>建议：</p><ol><li>对WHERE子句的字段建立索引，可以大幅提升查询效率。</li><li>采用聚集索引进行数据查询，比使用非聚集索引查询效率略高。如果查询次数较多，还是尽量使用主键索引进行数据查询。</li></ol><p>除了业务逻辑和物理实现方式，索引还可以按照字段个数进行划分，分成单一索引和联合索引。</p><p>索引列为一列时为单一索引；多个列组合在一起创建的索引叫做联合索引。</p><p>创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引（x，y，z）和（z，y，x）在使用的时候效率可能会存在差别。</p><p>这里需要说明的是联合索引存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。比如刚才举例的 (x, y, z)，如果查询条件是 WHERE x=1 AND y=2 AND z=3，就可以匹配上联合索引；如果查询条件是 WHERE y=2，就无法匹配上联合索引。</p><h3 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h3><p>数据库服务器的两种存储介质，分别为硬盘和内存。内存属于临时存储，容量有限，而当发生意外时会造成数据丢失；硬盘相当于永久存储介质，这也是为什么我们需要把数据保存到硬盘上。</p><p>虽然内存的读取速度很快，但我们还是需要将索引存放到硬盘上，这样的话，当我们在硬盘上进行查询时，也就产生了磁盘的I/O操作。相比于内存的存取来说，硬盘的I/O存取消耗的时间要高很多，所消耗的时间也就越大。如果我们能让索引的数据结构尽量减少硬盘的I/O操作，所消耗的时间也就越小。</p><h4 id="二叉树的局限性"><a href="#二叉树的局限性" class="headerlink" title="二叉树的局限性"></a>二叉树的局限性</h4><p>二分查找法是一种高效的数据检索方式，时间复杂度为O(log2n），是不是采用二叉树就适合作为索引的数据结构呢？</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>假设搜索插入的数值为key：</p><ol><li>如果key大于根节点，则在右子树种进行查找；</li><li>如果key小于根节点，则在左子树中进行查找；</li><li>如果key等于根节点，也就是找到了这个节点，返回根节点即可。</li></ol><p>例子，对数列（34，22，89，5，23，77，91）创造出来的二叉树如图：<br><img src="https://static01.imgkr.com/temp/c465fc5c2d85480488f42e1ac8164d6c.png" alt="image.png"></p><p>但是存在特殊的情况，就是有时候二叉树的深度非常大。比如（5，22，23，34，77，89，91）二叉搜索树如图所示：<br><img src="https://static01.imgkr.com/temp/556038be101c4745bdffed1dd8073e5a.png" alt="image.png"></p><p>可以看出来第一个数的深度时3，也就是说最多只需要3次比较，就可以找到节点，而第二棵树的深度时7，最多需要7次比较才能找到节点。</p><p>第二棵树也属于二分查找树，但是性能已经退化成了一条链表，查找数据的时间复杂度编程了O(n)。为了解决这个问题，人们提出了平衡二叉搜索树（AVL树），它在二分搜索树的基础上增加了约束，每个节点的左子树和右子树的高度不能超过1，也就是左子树和右子树仍然为平衡二叉树。</p><p>常见的平衡二叉树有很多种，包括了平衡二叉树、红黑树、数堆、伸展树。平衡二叉搜索树是最早提出来的自平衡二叉搜索树，当我们提到平衡二叉树时一般指的就是平衡二叉搜索树。事实上第一棵树就属于平衡二叉搜索树，搜索时间复杂度就是O(log2n)。</p><p>数据查询的时间主要依赖于磁盘I/O的次数，如果我们采用二叉树的形式，即使通过平衡二叉树进行了改进，树的深度也是O(log2n)，当n比较大时，深度也是比较高的，比如：<br><img src="https://static01.imgkr.com/temp/766d4b5674094a7cbb9af0c478263bb6.png" alt="image.png"></p><p>每访问一次节点就需要进行一次磁盘 I/O 操作，对于上面的树来说，我们需要进行 5 次 I/O 操作。虽然平衡二叉树比较的效率高，但是树的深度也同样高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率。</p><p>针对同样的数据，如果我们把二叉树改成了M叉树呢？当M=3时，同样的31个节点由三叉树进行存储：<br><img src="https://static01.imgkr.com/temp/a6fa9744fb354d2aad0db67964518a26.png" alt="image.png"></p><p>你能看到此时树的高度降低了，当数据量 N 大的时候，以及树的分叉数 M 大的时候，M 叉树的高度会远小于二叉树的高度。</p><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>如果使用二叉树作为索引的实现结构，会让树变的很高，增加硬盘的I/O次数，影响数据查询的时间。因此一个节点就不能只有2个子节点，而应该允许有M个子节点（M&gt;2）。</p><p>B树的出现就是为了解决这个问题的，英文时Balance Tree，也就是平衡多路搜索树，他的高度远小于平衡二叉树的高度。</p><p>B树的结构如下图所示：</p><p><img src="https://static01.imgkr.com/temp/cd8478bcece9462389cbd47539dd1902.png" alt="image.png"></p><p>B树作为平衡的多路搜索树，他的每一个节点最多可以包括M个子节点，M称为B树的阶。同时你能看到，每个磁盘块种包括了关键字和子节点的指针。如果一个磁盘块种包括了x个关键字，那么指针树就是x+1。对于一个100阶的B树来说，如果由三层的话最多可以存储约100万的索引数据。对于大量的索引数据来说，采用B树的结构是非常合适的，因为树的高度要远小二叉树的高度。</p><p>然后我们来看下如何用 B 树进行查找。假设我们想要查找的关键字是 9，那么步骤可以分为以下几步：</p><ol><li>我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1；</li><li>按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间， 所以我们得到指针 P2；</li><li>按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9</li></ol><p>你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行比较所需要的时间要多，是数据查找用时的重要因素，B 树相比于平衡二叉树来说磁盘 I/O 操作要少，在数据查询中比平衡二叉树效率要高。</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+树基于B树做出了改进，主流的DBMS都支持B+树的索引方式，比如MySQL。</p><p>与B树的差异有以下几点：</p><ol><li>k 个孩子的节点就有 k 个关键字。也就是孩子数量 = 关键字数，而 B 树中，孩子数量 = 关键字数 +1。<ol start="2"><li>非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）。</li><li>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中，非叶子节点既保存索引，也保存数据记录。</li><li>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</li></ol></li></ol><p><img src="https://static01.imgkr.com/temp/752a5cd4890746bea6ee634a923c2b7b.png" alt="image.png"></p><p>比如，我们想要查找关键字 16，B+ 树会自顶向下逐层进行查找：</p><ol><li>与根节点的关键字 (1，18，35) 进行比较，16 在 1 和 18 之间，得到指针 P1（指向磁盘块 2）</li><li>找到磁盘块 2，关键字为（1，8，14），因为 16 大于 14，所以得到指针 P3（指向磁盘块 7）</li><li>找到磁盘块 7，关键字为（14，16，17），然后我们找到了关键字 16，所以可以找到关键字 16 所对应的数据。</li></ol><p>整个过程一共进行了 3 次 I/O 操作，看起来 B+ 树和 B 树的查询过程差不多，但是 B+ 树和 B 树有个根本的差异在于，B+ 树的中间节点并不直接存储数据。这样的好处都有什么呢？</p><p>首先，B+ 树查询效率更稳定。因为 B+ 树每次只有访问到叶子节点才能找到对应的数据，而在 B 树中，非叶子节点也会存储数据，这样就会造成查询效率不稳定的情况，有时候访问到了非叶子节点就可以找到关键字，而有时需要访问到叶子节点才能找到关键字。</p><p>其次，B+ 树的查询效率更高，这是因为通常 B+ 树比 B 树更矮胖（阶数更大，深度更低），查询所需要的磁盘 I/O 也会更少。同样的磁盘页大小，B+ 树可以存储更多的节点关键字。</p><p>不仅是对单个关键字的查询上，在查询范围上，B+ 树的效率也比 B 树高。这是因为所有关键字都出现在 B+ 树的叶子节点中，并通过有序链表进行了链接。而在 B 树中则需要通过中序遍历才能完成查询范围的查找，效率要低很多。</p><p>总结<br>磁盘的 I/O 操作次数对索引的使用效率至关重要。虽然传统的二叉树数据结构查找数据的效率高，但很容易增加磁盘 I/O 操作的次数，影响索引使用的效率。因此在构造索引的时候，我们更倾向于采用“矮胖”的数据结构。</p><p>B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树，B+ 树在查询性能上更稳定，在磁盘页大小相同的情况下，树的构造更加矮胖，所需要进行的磁盘 I/O 次数更少，更适合进行关键字的范围查询。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧔Java常见面试题</title>
      <link href="/2020/09/04/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2020/09/04/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Java面向对象编程三大特征：封装-继承-多态"><a href="#1-Java面向对象编程三大特征：封装-继承-多态" class="headerlink" title="1.Java面向对象编程三大特征：封装 继承 多态"></a>1.Java面向对象编程三大特征：封装 继承 多态</h3><p><strong>封装</strong></p><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><p><strong>继承</strong></p><p>继承时使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便的复用以前的代码。</p><h6 id="关于继承的三点："><a href="#关于继承的三点：" class="headerlink" title="关于继承的三点："></a>关于继承的三点：</h6><p>1.子类拥有父类对象所有的属性和方法(包括私有属性和私有方法)，但是父类中的私有属性和方法子类是无法访问的，<strong>只是拥有</strong>。<br>2.子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>3.子类可以用自己的方式实现父类的方法</p><p><strong>多态</strong></p><p>所谓多态就是指程序中定义的应用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定的，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须由程序运行期间才能决定。</p><p>在Java中有两种形式可以实现多态:继承和接口</p><h3 id="2-String-StringBuffer-和-StringBuilder的区别是什么？String为什么是不可变的"><a href="#2-String-StringBuffer-和-StringBuilder的区别是什么？String为什么是不可变的" class="headerlink" title="2.String StringBuffer 和 StringBuilder的区别是什么？String为什么是不可变的"></a>2.String StringBuffer 和 StringBuilder的区别是什么？String为什么是不可变的</h3><p>可变性</p><p>简单的来说：String 类中使用的final关键字修饰字符数组保存字符串，private final char value[]，所以String对象是不可变的。</p><pre><code>补充：在Java9之后，String类的实现改用byte数组存储字符串 private final byte[] value</code></pre><p>而StringBuilder 与 StringBuffer 都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串char[] value 但是没有用final关键字修饰，所以这两种对象都是可变的，</p><p>线程安全性</p><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p><p>性能</p><p>每次对String类型进行改变的时候，都会产生一个新的String对象，然后将指针指向新的String对象。StringBuffer 每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并未改变对象的引用。相同情况下使用StringBuilder相比使用StringBuffer仅能获得10%~15%左右的性能提升，但却要冒线程不安全的风险。</p><p>对于三者的使用总结：</p><ol><li>操作少量的数据：使用String</li><li>单线程下操作大量数据：使用StringBuilder</li><li>多线程下操作大量数据：使用StringBuffer</li></ol><h3 id="2-Java集合框架"><a href="#2-Java集合框架" class="headerlink" title="2.Java集合框架"></a>2.Java集合框架</h3><p><strong>Collection</strong></p><ol><li>List</li></ol><ul><li>ArrayList Object数组</li><li>Vector Object数组</li><li>LinkedList 双向链表(jdk1.6之前为循环，jdk1.7取消了循环)</li></ul><ol start="2"><li>Set</li></ol><ul><li>HashSet (无需且唯一)：基于HashMap实现的，底层采用HashMap来保存元素</li><li>LinkedHashSet：LinkedHashSet继承于HashSet，并且其内部是通过LinkedHashMap来实现的。</li><li>TreeSet（有序唯一）</li></ul><p>Vector是Java早期早期提供的线程安全的动态数组，如果不是线程安全，并不建议选择，毕竟同步是有额外开销的。Vector内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</p><p>ArrayList是应用更加广泛的动态数组实现，他本身不是线程安全的，所以性能要好很多。与Vector近似，ArrayList也是可以根据需要调整容量（默认容量为10），不过两者的逻辑有所区别，<strong>Vector扩容时会提高1倍，而ArrayList则是增加50%。</strong></p><p>LinkedList顾名思义是Java提供双向链表，所以它不需要上面两种那样调整容量，他也不是线程安全的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧔Redis深度历险读书笔记</title>
      <link href="/2020/09/04/Redis%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
      <url>/2020/09/04/Redis%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis应用-分布式锁"><a href="#Redis应用-分布式锁" class="headerlink" title="Redis应用-分布式锁"></a>Redis应用-分布式锁</h2><p>分布式应用进行逻辑处理时经常会遇到并发问题。</p><p>比如一个操作要修改用户的状态，修改状态需要先读出用户的状态，在内存里进行修改，改完再存回去。如果这样的操作同时进行了，就会出现并发问题，因为读取和保存的两个操作不是原子的。</p><p>这个时候就要使用到分布式锁来限制程序的并发执行。Redis分布式锁使用非常广泛</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁本质上是要实现的目标就是在Redis里面占一个茅坑，当别的进程也要来占坑时，发现已经有人在那里了，就只好放弃或者稍后再试。</p><p>占坑一般是使用setnx （set if not exists）指令，只允许一个客户端占坑。先来先占，用完了，在调用del指令释放茅坑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;setnx lock:codehole  true</span><br><span class="line">OK</span><br><span class="line">....do something </span><br><span class="line">&gt;del lock:codehole&#39;  &#x2F;&#x2F;用来删除锁</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>但是有个问题，如果逻辑执行到中间出现异常了，可能会导致del指令没有调用，这样就会陷入死锁，锁永远得不到释放。</p><p>于是我们在拿到锁之后，再给锁加上一个过期时间，比如5秒，这样即使中间出现异常也可以保证5秒之后锁会的到释放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;setnx lock:codehole true </span><br><span class="line">OK</span><br><span class="line">&gt;expire lock:codehole 5</span><br><span class="line">... do something </span><br><span class="line">&gt;del lockLc:codehole </span><br><span class="line">(integer )1</span><br></pre></td></tr></table></figure><p>但是以上逻辑还是有问题。如果setnx 和 expire 之间服务器进程突然挂掉了，可能是因为机器掉电或者是被认为杀掉的，就可能导致expire得不到执行，也会造成死锁。</p><p>这种问题的根源就在于setnx 和 expire 是两条指令而不是原子指令。如果这两条指令可以一起执行就不会出现问题。</p><p>为了解决这个问题，Redis2.8版本中作者加入了set指令的扩展参数，使得setnx和expire指令可以一起执行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;set lock:codehole true ex 5 nx </span><br><span class="line">OK</span><br><span class="line">... dosomething </span><br><span class="line">&gt;del lock:codehole </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面的指令就是setnx和expire 组合在一起的原子指令，它就是分布式锁的奥义所在。</p><h3 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h3><p>Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁，但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻辑执行完之间拿到了锁。</p><p>为了避免这个问题，Redis分布式锁不要用较长时间的任务。如果真的偶尔出现了，数据的小波错乱可能需人工介入解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tag &#x3D; random.nextint()  # 随机数 </span><br><span class="line">if redis.set(key, tag, nx&#x3D;True, ex&#x3D;5):</span><br><span class="line">do_something() </span><br><span class="line">redis.delifequals(key, tag)  # 假象的 delifequals 指令 </span><br></pre></td></tr></table></figure><p>有一个更加安全的方案是为set指令的value 参数设置为一个随机数，释放锁时先匹配随机数是否一致，然后在删除key。但是匹配value 和 删除key不是一个原子操作，redis也没有提供类似于delifequals这样的指令，这就需要使用Lua脚本来处理了，因为Lua脚本可以保证连续多个指令的原子性操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># delifequals </span><br><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then    </span><br><span class="line">return redis.call(&quot;del&quot;,KEYS[1]) </span><br><span class="line">else</span><br><span class="line">return 0 end</span><br></pre></td></tr></table></figure><h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>可重入性是指线程在持有锁的情况下再次请求加锁，如果这一个锁支持同一个线程多次加锁，那么这个锁就是可重入的。比如Java语言里有个ReentrantLock就是可重入锁。Redis分布式锁如果要支持可重入，需要对客户端的set方法进行包装，使用线程的ThreadLocal变量存储当前持有锁的计数。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>在集群环境下，主节点挂掉时，从节点会取而代之，客户端上却并没有明显感知。原先第一个客户端在主节点中申请成功了一把锁，但是这把锁还没有来的及同步到从节点，主节点突然挂掉了。然后从节点变成了主节点，这个新的节点内部没有这把锁，所以但另一个客户端进来请求加锁时，立即就批准了。这样就会导致系统中同样一把锁被两个客户端同时持有，不安全由此产生。</p><p>不过这种不安全也仅仅是在主从发生 failover 的情况下才会产生，而且持续时间极短，业务系统多数情况下可以容忍。</p><h4 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h4><p>为了解决这个问题，Antirez发明了Redlock算法，他的流程比较复杂，不过有了很多开源的library做了良好的封装，用户拿来用即可</p><p>为了使用 Redlock，需要提供多个 Redis 实例，这些实例之前相互独立没有主从关系。同很多分布式算法一样，redlock 也使用「大多数机制」。 加锁时，它会向过半节点发送 set(key, value, nx=True, ex=xxx) 指令，只要过半节点 set 成功，那就认为加锁成功。释放锁时，需要向所有节点发送 del 指令。不过 Redlock 算法还需要考虑出错重试、时钟漂移等很多细节问题，同时因为 Redlock 需要向多个节点进行读写，意味着相比单实例 Redis 性能会下降一些</p><h4 id="Redlock使用场景"><a href="#Redlock使用场景" class="headerlink" title="Redlock使用场景"></a>Redlock使用场景</h4><p>如果你很在乎高可用性，希望挂了一台 redis 完全不受影响，那就应该考虑 redlock。不过代价也是有的，需要更多的 redis 实例，性能也下降了，代码上还需要引入额外的 library，运维上也需要特殊对待，这些都是需要考虑的成本，使用前请再三斟酌</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis深度历险 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧔Redis内存淘汰机制</title>
      <link href="/2020/09/04/Redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2020/09/04/Redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Redis中有个设置时间过期的功能，即对存储在redis中的值可以设置一个过期时间。如果设置了一批key只能存活1个小时，那么1小时候，redis会把这写key直接全部删掉吗？ redis是怎么做的呢？</p><p>redis主要采用两种机制来处理过起了的key，他并没有直接删除掉。</p><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>定期删除：redis默认每个100ms就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期了就删除，但是这里的key是随机抽取出来的，因为如果redis里有大量的key都设置了过期时间，每个100s去遍历所有的过期key，无疑会给cup带来压力。</p><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>惰性删除：定期删除可能会导致很多的key到了过期时间，却没有被删除掉，这导致redis中存在很多无用的key，除非系统去查一下这个key，这个key才会被redis给删除掉。这就是所谓的惰性删除。</p><p>但是仅仅通过这两种策略还是有问题的，如果没有及时去查，大量的过期key堆积在内存中，导致redis内存被消耗尽了。怎么解决呢？那就是redis的内存淘汰机制。</p><p>redis提供了6中数据淘汰策略：</p><ol><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的key淘汰。</li><li>volatile-random：从已设置过期时间的数据集中随机淘汰。</li><li>allkeys-lru：当前内存不足已容纳新写入的数据是，在所有的键中，挑选最近最少使用的键进行删除。</li><li>allkeys-random：从数据集中任意选择数据淘汰。</li><li>no-eviction：禁止驱逐数据，内存不足时就报错。</li></ol><h3 id="redis的持久化机制-怎么保证redis挂掉之后在重启数据可以恢复"><a href="#redis的持久化机制-怎么保证redis挂掉之后在重启数据可以恢复" class="headerlink" title="redis的持久化机制(怎么保证redis挂掉之后在重启数据可以恢复)"></a>redis的持久化机制(怎么保证redis挂掉之后在重启数据可以恢复)</h3><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，为的是重启机器，机器故障后恢复。</p><p>Redis支持两种不同的持久化操作，Redis的一种持久化方式叫快照（RDB），另外一种方式是只追加文件（append-only-file，AOF）。这两种方式各有千秋。</p><h4 id="快照持久化（RDB）"><a href="#快照持久化（RDB）" class="headerlink" title="快照持久化（RDB）"></a>快照持久化（RDB）</h4><p>Redis可以通过创建快照来获得存储在内存里面的数据在某个时间节点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构），还可以在原地以便重启服务器的时候使用。</p><p>Redis默认采用快照持久化，在redis.conf配置文件中默认有此下配置：</p><pre><code>save 900 1 #在900s之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 300 10 #在300s之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 60 10000 #在60s之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</code></pre><h4 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h4><p>与快照持久化相比，AOF有更好的实时性。默认情况下Redis没有开启AOF方式的持久化，可以通过appendonly参数开启：</p><pre><code>appendonly yes</code></pre><p>开启AOF持久化后每执行一条会更改Redis中的数据命令，Redis机会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appledonly.aof</p><p>在Redis的配置文件中存在三种不同的AOF持久化方式，分别是：</p><pre><code>appendfsync always   #每次有数据修改发生时都会写入AOF文件，这样会严重降低Reids的速度appendfsync everysec #每秒同步一次，显示的将多个写命令同步到磁盘appendfsync no       #让操作系统决定何时进行同步</code></pre><p>建议使用appendfsync everysec选项，让Redis每秒只同步一次AOF文件，Redis性能几乎没有受到任何影响。即使系统崩掉，最多只会丢失一秒之内产生的数据。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。</p><h3 id="RDB的优点"><a href="#RDB的优点" class="headerlink" title="RDB的优点"></a>RDB的优点</h3><ul><li><p>RDB的文件非常紧凑，他保存redis在某个时间上的数据集。</p></li><li><p>RDB适合灾难恢复：他只有一个文件，并且文件非常紧凑。</p></li><li><p>RDB可以最大化节省Redis的性能：父进程在保存RDB的时候只需要<strong>fork</strong>出一个进程即可，父进程无需执行磁盘的IO。</p></li><li><p>RDB在恢复大数据集的时候要比AOF快。</p><h3 id="RDB的缺点"><a href="#RDB的缺点" class="headerlink" title="RDB的缺点"></a>RDB的缺点</h3></li><li><p>如果你要尽量避免Redis在出问题的时候丢失数据，那RDB可能不合适，一旦停机他可能会失去好几分钟的数据。相信这是没人可以接受的。</p></li><li><p>每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。</p></li></ul><h3 id="AOF的优点"><a href="#AOF的优点" class="headerlink" title="AOF的优点"></a>AOF的优点</h3><ul><li>使用AOF会让Redis变得非常耐久，比如：你可以设置不同的策略，比如每秒钟同步一次，一秒钟同步一次(默认)，每写一次同步一次，默认就可以很节省性能，而且最多也就丢失一秒的数据。</li><li>AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。</li><li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</li></ul><h3 id="AOF的缺点"><a href="#AOF的缺点" class="headerlink" title="AOF的缺点"></a>AOF的缺点</h3><ul><li>对于相同的数据集来说，AOF的文件大小要比RDB的大。</li><li>根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 内存淘汰机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧔Redis基础知识</title>
      <link href="/2020/09/04/Redis%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/09/04/Redis%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>简单来说redis就是一个数据库，不过与传统的数据库不同的是<br>redis的数据是存在内存中的，所以读写速度非常快，因此redis被广泛应用于缓存方向。另外，redis也经常来做分布式锁。redis提供了多种数据类型来支持不同的业务场景。</p><h2 id="Redis常见的数据结构以及使用场景分析"><a href="#Redis常见的数据结构以及使用场景分析" class="headerlink" title="Redis常见的数据结构以及使用场景分析"></a>Redis常见的数据结构以及使用场景分析</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><pre><code>常用命令：set，get，decr，incr，mget等。</code></pre><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。常规计数：微博数，粉丝数等。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><pre><code>常用命令：hget，hset，hgetall等。</code></pre><p>hash是一个string类型的field和value的映射表，hash特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。比如:</p><pre><code>key=uservalue=&#123;    &quot;id&quot;:1,    &quot;name&quot;:&quot;test&quot;,    &quot;age&quot;:22&#125;</code></pre><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><pre><code>常用命令：lpush，rpush，lpop，lrange</code></pre><p>List就是链表，Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表。</p><p>Redis list 的实现为一个双向链表，既可以支持方向查找和遍历，更方便操作，不过带来了额外的内存开销。</p><p>另外可以通过lrange命令，就是从某个元素的开始读取多少个元素，可以基于list实现分页查询，这个很棒，基于redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><pre><code>常用命令：sadd，spop，smembers，sinion等</code></pre><p>set对外提供的功能与list类似是一个列表的功能，特殊之外在于set是可以排重的。</p><p>当你需要存储一个列表数据，又不希望有重复数据时，set时一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个时list不能提供的。可以通过set轻易实现交集，并集，补集，差集。</p><pre><code>判断member是否在set中    sismember key member    存在返回1，0表示不存在或者key不存在    </code></pre><p>比如：在微博应用中，将一个用户的所有关注存在一个set中，并将其粉丝存在一个集合中，redis可以非常方便的实现共同关注，共同爱好的功能。</p><pre><code>sinterstore dstkey key1...keyN   将key1~keyn的交集存入dskey中</code></pre><h3 id="Sorted-Set"><a href="#Sorted-Set" class="headerlink" title="Sorted Set"></a>Sorted Set</h3><pre><code>常用命令：zadd，zrange，zrem，zcard等</code></pre><p>和set相比sorted set增加了一个权重参数score，使得集合中的元素能够按照score进行排序。</p><p>举例：在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息等信息。</p><h3 id="redis设置过期时间"><a href="#redis设置过期时间" class="headerlink" title="redis设置过期时间"></a>redis设置过期时间</h3><p>Redis中有个设置时间过期的功能，即对存储在redis数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如短信验证码。</p><p>在set key的时候，都可以给一个expire time，就是过期时间，通过过期时间指定这个key可以存过的时间。</p><p><strong>下篇文章介绍redis的内存淘汰机制</strong></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🕵️‍♂️RabbitMQ 实现延迟消息（以订单超时为例）</title>
      <link href="/2020/09/04/RabbitMQ%20%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%EF%BC%88%E4%BB%A5%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E4%B8%BA%E4%BE%8B%EF%BC%89/"/>
      <url>/2020/09/04/RabbitMQ%20%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%EF%BC%88%E4%BB%A5%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E4%B8%BA%E4%BE%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h5 id="铺垫"><a href="#铺垫" class="headerlink" title="铺垫"></a>铺垫</h5><p>RabbitMQ延迟消息以来的是其死信机制</p><p>首先启动RabbitMQ服务器，并在配置文件配置好相关配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">localhost</span>      <span class="comment"># ip地址</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5672</span>           <span class="comment"># 端口</span></span><br><span class="line">  <span class="attr">virtual-host:</span> <span class="string">/mall</span>  <span class="comment">#虚拟机</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">mall</span>       <span class="comment">#用户名</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">mall</span>       <span class="comment">#密码</span></span><br><span class="line">  <span class="attr">publisher-confirms:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>整体流程图</strong><br><img src="http://www.yinshi.网址:8090/upload/2020/3/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6-4ec6438a8a3c486cb45a4c8f462d4017.png" alt="延迟消息.png"></p><h3 id="一、使用SpringDataRabbitMQ配置MQ的交换机与队列"><a href="#一、使用SpringDataRabbitMQ配置MQ的交换机与队列" class="headerlink" title="一、使用SpringDataRabbitMQ配置MQ的交换机与队列"></a>一、使用SpringDataRabbitMQ配置MQ的交换机与队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMqConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *订单队列中消息超时后将消息发送到这个交换机</span></span><br><span class="line"><span class="comment">     * 相当于死信交换机</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">DirectExchange <span class="title">orderDirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) ExchangeBuilder.directExchange(<span class="string">&quot;order.exchange&quot;</span>)</span><br><span class="line">                .durable(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将订单消息推送到订单队列的交换机</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">orderTtlDirect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (DirectExchange) ExchangeBuilder.directExchange(<span class="string">&quot;order.ttl.exchange&quot;</span>)</span><br><span class="line">                .durable(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *接收取消订单的消息队列(超时后消息转发到这个队列)</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">orderQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;order.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收订单的消息队列，到期后转发消息转发到orderDirect</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * **/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">orderTtlQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(<span class="string">&quot;orderTtl.queue&quot;</span>)</span><br><span class="line">                .withArgument(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,<span class="string">&quot;order.exchange&quot;</span>) <span class="comment">//过期后发送的交换机</span></span><br><span class="line">                .withArgument(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;order&quot;</span>) <span class="comment">//过期后发送的routingkey</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定订单队列到交换机</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">orderTtlBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(orderTtlQueue())</span><br><span class="line">                .to(orderTtlDirect())</span><br><span class="line">                .with(<span class="string">&quot;orderTtl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取消订单的消息绑定交换机</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">orderBinding</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(orderQueue())</span><br><span class="line">                .to(orderDirect())</span><br><span class="line">                .with(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、添加消息发送方"><a href="#二、添加消息发送方" class="headerlink" title="二、添加消息发送方"></a>二、添加消息发送方</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelOrderSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(CancelOrderSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息类型为Long的订单id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Long orderId)</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;order.ttl.exchange&quot;</span>,<span class="string">&quot;orderTtl&quot;</span></span><br><span class="line">                , orderId, <span class="keyword">new</span> MessagePostProcessor() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line">                        message.getMessageProperties().setExpiration(<span class="string">&quot;5000&quot;</span>);<span class="comment">//过期时间为5秒</span></span><br><span class="line">                        <span class="keyword">return</span> message;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        logger.info(<span class="string">&quot;send delay message orderId:&#123;&#125;&quot;</span>,orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三、启动测试查看日志输出"><a href="#三、启动测试查看日志输出" class="headerlink" title="三、启动测试查看日志输出"></a>三、启动测试查看日志输出</h3><p>5秒后收到了过期的消息</p><p><img src="http://www.yinshi.网址:8090/upload/2020/3/TIM%E6%88%AA%E5%9B%BE20200307231052-aac98a5ba4e0447fbb81a4fcf1b114f4.png" alt="TIM截图20200307231052.png"></p><p>到此结束！</p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> 延迟队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>🧙‍♀️RabbitMQ入门</title>
      <link href="/2020/09/04/RabbitMQ%E5%85%A5%E9%97%A8/"/>
      <url>/2020/09/04/RabbitMQ%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。</p><h1 id="相关定义"><a href="#相关定义" class="headerlink" title="相关定义"></a>相关定义</h1><ul><li>Broker： 简单来说就是消息队列服务器实体</li><li>Exchange：它指定消息按什么规则，路由到哪个队列</li><li>Queue：消息队列的载体，每个消息都会投入到一个或多个消息队列中</li><li>Binding：绑定，它的作用就是把exchange和queue按照路由规则绑定起来</li><li>Routing Key： 路由关键字，exchange根据这个关键字进行消息投递</li><li>VHost： 虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。</li><li>Producer： 消息生产者，就是投递消息的程序</li><li>Consumer： 消息消费者，就是接受消息的程序</li><li>Channel： 消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务</li></ul><p><strong>由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路。</strong></p><h1 id="RabbitMQ的工作模式"><a href="#RabbitMQ的工作模式" class="headerlink" title="RabbitMQ的工作模式"></a>RabbitMQ的工作模式</h1><p> RabbitMQ的官方网站中一共介绍了6种工作模式。<a href="https://www.rabbitmq.com/getstarted.html">6种工作模式</a></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="1-Hello-world-简单模式"><a href="#1-Hello-world-简单模式" class="headerlink" title="1. Hello world 简单模式"></a>1. Hello world 简单模式</h3><p><img src="https://static01.imgkr.com/temp/9f706b05f5b64d91917014687d6cbab6.png" alt="image.png"></p><p>P：生产者：也就是要发送消息的程序</p><p>C：消费者：消息的接受者会监听消息生产者，会一直等待消息到来</p><p>应用场景: 聊天</p><p><strong>Producter 如果发送消息时，如果发送的队列没有绑定交换机和routing key的话，那么将会使用默认的交换机并且将发送的消息队列名作为routing key</strong></p><h3 id="2-Work-queues-工作模式"><a href="#2-Work-queues-工作模式" class="headerlink" title="2. Work queues 工作模式"></a>2. Work queues 工作模式</h3><p><img src="https://static01.imgkr.com/temp/ec86c4977cc44aa3adb78db41dd31934.png" alt="image.png"></p><p>多个消费者监听只听同一名称的队列消费消息（消费者属于竞争关系）</p><h3 id="3-Publish-发布与订阅模式"><a href="#3-Publish-发布与订阅模式" class="headerlink" title="3.Publish 发布与订阅模式"></a>3.Publish 发布与订阅模式</h3><p><img src="https://static01.imgkr.com/temp/3e843a1e17d34746a32c8889331d6e47.png" alt="image.png"></p><p>这种模式添加了一个角色X即交换机Exchange</p><p>多个队列绑定相同的交换机接收相同的消息<br>多个消费者监听相对的队列接收相同的消息</p><p><strong>这种模式需要使用fanout 类型的交换机，这种交换机不处理routing key 只需要将队列绑定到交换机上就可以，因此，fanout类型的交换机转发消息是最快的。</strong> </p><h3 id="4-Routing-路由模式"><a href="#4-Routing-路由模式" class="headerlink" title="4.Routing 路由模式"></a>4.Routing 路由模式</h3><p><img src="https://static01.imgkr.com/temp/b8baa95a8bed4f27b3b0fbc6206f2784.png" alt="image.png"></p><p><strong>队列通过routingkey 绑定 direct类型的交换机，生产者向交换机发送消息时，也需要指定相应的routingkey 交换机就会把这个routingkey对应的消息发送到绑定改rotingkey的队列中，如果routingkey不一致则交换机不会把消息发送到队列中</strong></p><h3 id="5-Topics-通配符模式"><a href="#5-Topics-通配符模式" class="headerlink" title="5.Topics 通配符模式"></a>5.Topics 通配符模式</h3><p><img src="https://static01.imgkr.com/temp/6e3323bea2cc4dbbb733948431929e67.png" alt="image.png">v</p><p>Exchange：使用topic模式的交换机，这种类型的交换机与direct相比就是在绑定routingkey时可以使用通配符</p><p>通配符匹配规则</p><p>#：匹配一个或多个词</p><p>*：匹配不多不少恰好1个词</p><p>举例：</p><p><strong>item.#：</strong> 能够匹配<code>item.insert.abc</code>或者<code>item.insert</code></p><p>*<em>item.<em>：</em></em>只能匹配<code>item.insert</code></p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
